

  <!-- Mini Canvas Editor CSS -->
  <link rel="stylesheet" href="https://unpkg.com/mini-canvas-editor@latest/dist/style.css">

  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #editor-container {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #333;
      cursor: grab;
    }

    #toolbar {
      background: #1e1e1e;
      color: white;
      padding: 8px 12px;
      font-family: sans-serif;
    }

    canvas {
      background: #444;
      border-radius: 4px;
      margin: 50px;
    }
  </style>
</head>

<body>
  <div id="toolbar">
    <button id="openImage">Open Image</button>
    <button id="resetView">Reset View</button>
  </div>

  <div id="editor-container">
    <div id="editor"></div>
  </div>

  <!-- Mini Canvas Editor JS -->
  <script src="https://unpkg.com/mini-canvas-editor@latest/dist/mini-canvas-editor.umd.js"></script>

  <script>
    // Initialize Mini Canvas Editor
    const editor = new MiniCanvasEditor({
      el: '#editor',
      width: 1000,
      height: 700
    });

    // Load an example image
    const img = new Image();
    img.src = 'https://picsum.photos/1600/900';
    img.onload = () => {
      editor.addImage(img.src);
    };

    // Smooth zoom and pan logic
    const container = document.getElementById('editor-container');
    let scale = 1.0;
    let isDragging = false;
    let lastX, lastY;

    container.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = 1.15;
      if (e.deltaY < 0) scale *= zoomFactor;
      else scale /= zoomFactor;
      scale = Math.min(Math.max(0.2, scale), 8);
      editor.canvas.setZoom(scale);
      editor.canvas.requestRenderAll();
    }, { passive: false });

    container.addEventListener('mousedown', e => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      container.style.cursor = 'grabbing';
    });

    container.addEventListener('mouseup', () => {
      isDragging = false;
      container.style.cursor = 'grab';
    });

    container.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      const viewport = editor.canvas.viewportTransform;
      viewport[4] += dx;
      viewport[5] += dy;
      editor.canvas.setViewportTransform(viewport);
      lastX = e.clientX;
      lastY = e.clientY;
    });

    // Reset view
    document.getElementById('resetView').onclick = () => {
      scale = 1;
      editor.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      editor.canvas.setZoom(scale);
      editor.canvas.requestRenderAll();
    };

    // Open a new image
    document.getElementById('openImage').onclick = async () => {
      const fileHandle = await window.showOpenFilePicker({
        types: [{ description: 'Images', accept: { 'image/*': ['.png', '.jpg', '.jpeg'] } }]
      });
      const file = await fileHandle[0].getFile();
      const url = URL.createObjectURL(file);
      editor.addImage(url);
    };
  </script>