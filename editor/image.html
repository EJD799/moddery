<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Art Editor</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
<style>
html, body {
  margin: 0; padding: 0; height: 100%;
  font-family: Verdana, sans-serif;
  background: #111; color: #fff;
  display: flex; flex-direction: column;
}
#toolbar {
  display: flex; flex-wrap: wrap; align-items: center;
  gap: 4px; background: #222; padding: 4px;
}
#toolbar button {
  display: flex; align-items: center; gap: 4px;
  padding: 4px 8px; background: #333; color: #fff;
  border: none; cursor: pointer;
}
#toolbar button.active { background: #555; }
#toolbar input[type=color], #toolbar input[type=range] { margin-left: 4px; }
#canvasContainer {
  flex: 1; position: relative; overflow: hidden;
  background: #222; display: flex;
  justify-content: center; align-items: center;
}
canvas { image-rendering: pixelated; display: block; }
</style>
</head>
<body>

<div id="toolbar">
  <button id="toolPencil" class="active"><i class="fas fa-pencil-alt"></i>Pencil</button>
  <button id="toolRect"><i class="fas fa-square"></i>Rectangle</button>
  <button id="toolFill"><i class="fas fa-fill-drip"></i>Fill</button>
  <button id="toolEraser"><i class="fas fa-eraser"></i>Eraser</button>
  <button id="toolEyedropper"><i class="fas fa-eye-dropper"></i>Eyedropper</button>
  <button id="toolHueBrush"><i class="fas fa-adjust"></i>Hue Brush</button>
  <button id="toolText"><i class="fas fa-font"></i>Text</button>
  <label>Color:<input type="color" id="colorPicker" value="#ff0000"></label>
  <label>Brush:<input type="range" id="brushSize" min="1" max="16" value="1"></label>
  <button id="undoBtn"><i class="fas fa-undo"></i>Undo</button>
  <button id="redoBtn"><i class="fas fa-redo"></i>Redo</button>
  <button id="saveBtn"><i class="fas fa-download"></i>Save</button>
  <button id="loadBtn"><i class="fas fa-upload"></i>Load</button>
  <input type="file" id="fileInput" style="display:none">
</div>

<div id="canvasContainer">
  <canvas id="pixelCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const container = document.getElementById('canvasContainer');

let gridWidth = 16, gridHeight = 16;
let pixelSize = 1;
let scale = 32;
let offsetX = 0, offsetY = 0;
let brushSize = 1;
let currentTool = 'pencil';
let currentColor = '#ff0000';
let isDrawing = false;
let startX = 0, startY = 0;
let previewRect = null;
let lastMouseEvent = null;

// Logical pixel data canvas
const bgCanvas = document.createElement('canvas');
bgCanvas.width = gridWidth;
bgCanvas.height = gridHeight;
const bgCtx = bgCanvas.getContext('2d');

// Undo/redo
let undoStack = [], redoStack = [];
function saveState(){ redoStack=[]; undoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight)); if(undoStack.length>50) undoStack.shift(); }
function undo(){ if(undoStack.length){ redoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight)); bgCtx.putImageData(undoStack.pop(),0,0); render(); }}
function redo(){ if(redoStack.length){ undoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight)); bgCtx.putImageData(redoStack.pop(),0,0); render(); }}

// Checkerboard pattern
const patternCanvas = document.createElement('canvas');
patternCanvas.width = patternCanvas.height = 16;
const pctx = patternCanvas.getContext('2d');
pctx.fillStyle = '#aaa'; pctx.fillRect(0,0,8,8); pctx.fillRect(8,8,8,8);
pctx.fillStyle = '#ccc'; pctx.fillRect(8,0,8,8); pctx.fillRect(0,8,8,8);
const checkerPattern = ctx.createPattern(patternCanvas,'repeat');

// Color utils
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;let max=Math.max(r,g,b),min=Math.min(r,g,b),h,s,l=(max+min)/2;if(max===min){h=s=0;}else{let d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h*=60;}return [h,s,l];}
function hslToRgb(h,s,l){h/=360;let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s; const p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);} return [r*255,g*255,b*255];}

// Helpers
function colorToRGBA(c){const tmp=document.createElement('canvas').getContext('2d'); tmp.fillStyle=c; tmp.fillRect(0,0,1,1); return tmp.getImageData(0,0,1,1).data;}
function getPixelColor(x,y){const d=bgCtx.getImageData(x,y,1,1).data;return`rgba(${d[0]},${d[1]},${d[2]},${d[3]/255})`;}
function rgbaToHex(rgba){const m=rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?/); if(!m) return '#000000'; const [_,r,g,b]=m; return '#'+((1<<24)+(parseInt(r)<<16)+(parseInt(g)<<8)+parseInt(b)).toString(16).slice(1);}

// Drawing
function drawPixel(x,y,color,ctxToUse=bgCtx){
  const half = Math.floor(brushSize/2);
  for(let dx=-half;dx<half+brushSize%2;dx++){
    for(let dy=-half;dy<half+brushSize%2;dy++){
      const px=x+dx, py=y+dy;
      if(px<0||py<0||px>=gridWidth||py>=gridHeight) continue;
      if(color==='eraser'){ctxToUse.clearRect(px,py,1,1);}
      else if(color==='hue'){
        const d=ctxToUse.getImageData(px,py,1,1);
        const [r,g,b]=d.data;
        let [h,s,l]=rgbToHsl(r,g,b);
        h=(h+180)%360;
        const [nr,ng,nb]=hslToRgb(h,s,l);
        d.data[0]=nr;d.data[1]=ng;d.data[2]=nb;ctxToUse.putImageData(d,px,py);
      } else {
        ctxToUse.fillStyle=color; ctxToUse.fillRect(px,py,1,1);
      }
    }
  }
}

// Flood fill
function floodFill(x,y,color){
  const data=bgCtx.getImageData(0,0,gridWidth,gridHeight);
  const idx=(y*gridWidth+x)*4;
  const target=[data.data[idx],data.data[idx+1],data.data[idx+2],data.data[idx+3]];
  const fill=colorToRGBA(color);
  if(target.every((v,i)=>v===fill[i])) return;
  const stack=[[x,y]];
  while(stack.length){
    const [cx,cy]=stack.pop();
    if(cx<0||cy<0||cx>=gridWidth||cy>=gridHeight) continue;
    const i=(cy*gridWidth+cx)*4;
    if(data.data[i]!==target[0]||data.data[i+1]!==target[1]||data.data[i+2]!==target[2]||data.data[i+3]!==target[3]) continue;
    data.data[i]=fill[0];data.data[i+1]=fill[1];data.data[i+2]=fill[2];data.data[i+3]=fill[3];
    stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
  }
  bgCtx.putImageData(data,0,0); render();
}

// Rectangles
function drawRect(x1,y1,x2,y2,color){
  const xmin=Math.min(x1,x2), xmax=Math.max(x1,x2);
  const ymin=Math.min(y1,y2), ymax=Math.max(y1,y2);
  for(let x=xmin;x<=xmax;x++) for(let y=ymin;y<=ymax;y++) drawPixel(x,y,color,bgCtx);
}

// Mouse helpers
function getMousePos(e){
  const rect=canvas.getBoundingClientRect();
  const mx=(e.clientX-rect.left-offsetX)/scale;
  const my=(e.clientY-rect.top-offsetY)/scale;
  return {x:Math.floor(mx), y:Math.floor(my)};
}

// Render
function render(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const imgW=gridWidth*scale, imgH=gridHeight*scale;
  const cx=(container.clientWidth-imgW)/2+offsetX;
  const cy=(container.clientHeight-imgH)/2+offsetY;

  ctx.translate(cx,cy);
  ctx.scale(scale,scale);
  ctx.fillStyle=checkerPattern;
  ctx.fillRect(0,0,gridWidth,gridHeight);
  ctx.imageSmoothingEnabled=false;
  ctx.drawImage(bgCanvas,0,0);
  if(previewRect){
    ctx.globalAlpha=0.4; ctx.fillStyle=currentColor;
    ctx.fillRect(previewRect.x,previewRect.y,previewRect.w,previewRect.h);
    ctx.globalAlpha=1;
  }
}

// Mouse handling
let isPanning=false,lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{
  if(e.button===1){isPanning=true;lastX=e.clientX;lastY=e.clientY;canvas.style.cursor='move';return;}
  const pos=getMousePos(e); startX=pos.x; startY=pos.y; isDrawing=true;
  if(['pencil','eraser','fill','rect','hue','text'].includes(currentTool)) saveState();
  if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor);
  if(currentTool==='eraser') drawPixel(pos.x,pos.y,'eraser');
  if(currentTool==='fill') floodFill(pos.x,pos.y,currentColor);
  if(currentTool==='eyedropper'){const c=getPixelColor(pos.x,pos.y); currentColor=c; document.getElementById('colorPicker').value=rgbaToHex(c);}
  if(currentTool==='text'){const text=prompt("Enter text:"); if(text){bgCtx.fillStyle=currentColor; bgCtx.font="1px monospace"; bgCtx.fillText(text,pos.x,pos.y+1);} render();}
  render();
});
canvas.addEventListener('mousemove',e=>{
  if(isPanning){offsetX+=e.movementX;offsetY+=e.movementY;render();return;}
  if(!isDrawing) return;
  const pos=getMousePos(e);
  if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor);
  if(currentTool==='eraser') drawPixel(pos.x,pos.y,'eraser');
  if(currentTool==='rect'){const x=Math.min(startX,pos.x),y=Math.min(startY,pos.y),w=Math.abs(pos.x-startX)+1,h=Math.abs(pos.y-startY)+1;previewRect={x,y,w,h};}
  if(currentTool==='hue') drawPixel(pos.x,pos.y,'hue');
  render();
});
canvas.addEventListener('mouseup',e=>{
  if(currentTool==='rect' && previewRect){drawRect(startX,startY,startX+previewRect.w-1,startY+previewRect.h-1,currentColor);previewRect=null;}
  isDrawing=false;isPanning=false;canvas.style.cursor='crosshair';render();
});

// Toolbar
const tools={pencil:'toolPencil',rect:'toolRect',fill:'toolFill',eraser:'toolEraser',eyedropper:'toolEyedropper',hue:'toolHueBrush',text:'toolText'};
function selectTool(t){currentTool=t;for(const k in tools){document.getElementById(tools[k]).classList.toggle('active',k===t);}}
for(const k in tools){document.getElementById(tools[k]).onclick=()=>selectTool(k);}
document.getElementById('colorPicker').oninput=e=>currentColor=e.target.value;
document.getElementById('brushSize').oninput=e=>brushSize=parseInt(e.target.value);
document.getElementById('undoBtn').onclick=undo;
document.getElementById('redoBtn').onclick=redo;

// Zoom centered on mouse
canvas.addEventListener('wheel',e=>{
  e.preventDefault();
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const zoomFactor = 1 - e.deltaY*0.0015;
  const newScale=Math.min(Math.max(scale*zoomFactor,0.06),64);
  offsetX-=(mx-container.clientWidth/2)*(newScale/scale-1);
  offsetY-=(my-container.clientHeight/2)*(newScale/scale-1);
  scale=newScale; render();
},{passive:false});

// Save/load
function saveProject(){const c=document.createElement('canvas');c.width=gridWidth;c.height=gridHeight;c.getContext('2d').drawImage(bgCanvas,0,0);return c.toDataURL('image/png');}
function loadProject(data){const img=new Image();img.onload=()=>{gridWidth=img.width;gridHeight=img.height;bgCanvas.width=gridWidth;bgCanvas.height=gridHeight;bgCtx.drawImage(img,0,0);render();};img.src=data;}
document.getElementById('saveBtn').onclick=()=>{const a=document.createElement('a');a.href=saveProject();a.download='pixel.png';a.click();};
document.getElementById('loadBtn').onclick=()=>document.getElementById('fileInput').click();
document.getElementById('fileInput').onchange=e=>{const f=e.target.files[0];if(!f)return;const r=new FileReader();r.onload=ev=>loadProject(ev.target.result);r.readAsDataURL(f);};

// Init
function resizeCanvas(){canvas.width=container.clientWidth;canvas.height=container.clientHeight;render();}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();
render();
</script>
</body>
</html>
