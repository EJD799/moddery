<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Editor â€” Full Version</title>
<style>
  html, body {
    margin:0; height:100%; overflow:hidden;
    background:#000;
    font-family: Verdana, sans-serif;
  }
  #toolbar {
    display:flex;
    background:#111;
    padding:8px;
    color:#fff;
    align-items:center;
    gap:4px;
  }
  #toolbar button.active {
    background:#333;
  }
  #work {
    position:relative;
    width:100%;
    height:calc(100% - 40px);
    overflow:hidden;
    cursor:crosshair;
  }
  canvas {
    display:block;
  }
  input[type=color] {
    margin-left:8px;
  }
</style>
</head>
<body>

<div id="toolbar">
  <button data-tool="move" class="active">Move</button>
  <button data-tool="rect">Rectangle</button>
  <button data-tool="brush">Brush</button>
  <button data-tool="eraser">Eraser</button>
  <button data-tool="eyedropper">Eyedropper</button>
  <input type="color" id="colorPicker" value="#ff0000">
  <button id="btnOpen">Open</button>
  <button id="btnSave">Save</button>
  <span style="margin-left:8px;">Scroll to pan, pinch to zoom</span>
</div>

<div id="work">
  <canvas id="editorCanvas"></canvas>
</div>

<script>
// -------------------- CORE CANVAS --------------------
const canvas = document.getElementById('editorCanvas');
const ctx = canvas.getContext('2d');

let canvasWidth = 16;
let canvasHeight = 16;

let pixelSize = 16; // zoom
let offsetX = 0;
let offsetY = 0;

let currentTool = 'move';
let currentColor = '#ff0000';
let drawing = false;
let startX=0, startY=0;
let pixelData = [];

// Initialize empty pixel buffer
function initBuffer(w,h){
  canvasWidth=w; canvasHeight=h;
  pixelData=[];
  for(let y=0;y<h;y++){
    pixelData[y]=[];
    for(let x=0;x<w;x++) pixelData[y][x]=null;
  }
  canvas.width=w*pixelSize;
  canvas.height=h*pixelSize;
}
initBuffer(16,16);

// -------------------- TOOLBAR --------------------
const toolbarButtons = document.querySelectorAll('#toolbar [data-tool]');
toolbarButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    currentTool=btn.dataset.tool;
    toolbarButtons.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
  });
});

document.getElementById('colorPicker').addEventListener('input', e=>{
  currentColor=e.target.value;
});

// -------------------- RENDER --------------------
function render(){
  canvas.width=canvasWidth*pixelSize;
  canvas.height=canvasHeight*pixelSize;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(pixelSize, pixelSize);

  // Draw pixels
  for(let y=0;y<canvasHeight;y++){
    for(let x=0;x<canvasWidth;x++){
      const col = pixelData[y][x];
      if(col){
        ctx.fillStyle=col;
        ctx.fillRect(x,y,1,1);
      } else {
        ctx.fillStyle='rgba(0,0,0,0)';
        ctx.fillRect(x,y,1,1);
      }
    }
  }
  ctx.restore();
}

// -------------------- DRAWING --------------------
canvas.addEventListener('mousedown', e=>{
  const px = Math.floor((e.offsetX - offsetX)/pixelSize);
  const py = Math.floor((e.offsetY - offsetY)/pixelSize);
  startX=px; startY=py;
  drawing=true;
  drawPixel(px,py);
});

canvas.addEventListener('mousemove', e=>{
  if(!drawing) return;
  const px = Math.floor((e.offsetX - offsetX)/pixelSize);
  const py = Math.floor((e.offsetY - offsetY)/pixelSize);
  drawPixel(px,py);
});

canvas.addEventListener('mouseup', ()=>drawing=false);
canvas.addEventListener('mouseleave', ()=>drawing=false);

function drawPixel(x,y){
  if(x<0||y<0||x>=canvasWidth||y>=canvasHeight) return;
  switch(currentTool){
    case 'brush': pixelData[y][x]=currentColor; break;
    case 'eraser': pixelData[y][x]=null; break;
    case 'rect':
      const minX=Math.min(startX,x), maxX=Math.max(startX,x);
      const minY=Math.min(startY,y), maxY=Math.max(startY,y);
      for(let yy=minY;yy<=maxY;yy++){
        for(let xx=minX;xx<=maxX;xx++){
          pixelData[yy][xx]=currentColor;
        }
      }
      break;
    case 'eyedropper':
      const c = pixelData[y][x];
      if(c) {
        currentColor=c;
        document.getElementById('colorPicker').value=c;
      }
      break;
  }
  render();
}

// -------------------- SCROLL / PINCH --------------------
let isTouchPinch=false, touchStartDist=0, lastPixelSize=pixelSize;
let startOffsetX=offsetX, startOffsetY=offsetY;

const work = document.getElementById('work');

work.addEventListener('wheel', e=>{
  e.preventDefault();
  const isPinch = e.ctrlKey || e.metaKey || (Math.abs(e.deltaX)<0.1 && Math.abs(e.deltaY)<0.1 && Math.abs(e.deltaZ)>0);

  if(isPinch){
    const rect = work.getBoundingClientRect();
    const pointerX=(e.clientX-rect.left - offsetX)/pixelSize;
    const pointerY=(e.clientY-rect.top - offsetY)/pixelSize;

    const zoomFactor = e.deltaY<0 ? 1.06 : 1/1.06;
    const newPixelSize=Math.min(Math.max(pixelSize*zoomFactor,1),128);
    offsetX -= pointerX*(newPixelSize - pixelSize);
    offsetY -= pointerY*(newPixelSize - pixelSize);
    pixelSize=newPixelSize;
    render();
  } else {
    offsetX-=e.deltaX;
    offsetY-=e.deltaY;
    render();
  }
},{passive:false});

// Touch pinch for mobile
work.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    isTouchPinch=true;
    const dx=e.touches[0].clientX - e.touches[1].clientX;
    const dy=e.touches[0].clientY - e.touches[1].clientY;
    touchStartDist=Math.hypot(dx,dy);
    lastPixelSize=pixelSize;
    startOffsetX=offsetX;
    startOffsetY=offsetY;
  }
});
work.addEventListener('touchmove', e=>{
  if(isTouchPinch && e.touches.length===2){
    e.preventDefault();
    const dx=e.touches[0].clientX - e.touches[1].clientX;
    const dy=e.touches[0].clientY - e.touches[1].clientY;
    const dist=Math.hypot(dx,dy);
    const zoomFactor=dist/touchStartDist;
    const newPixelSize=Math.min(Math.max(lastPixelSize*zoomFactor,1),128);

    const rect=work.getBoundingClientRect();
    const centerX=(e.touches[0].clientX+e.touches[1].clientX)/2 - rect.left;
    const centerY=(e.touches[0].clientY+e.touches[1].clientY)/2 - rect.top;

    offsetX=startOffsetX - (centerX/lastPixelSize)*(newPixelSize-lastPixelSize);
    offsetY=startOffsetY - (centerY/lastPixelSize)*(newPixelSize-lastPixelSize);
    pixelSize=newPixelSize;
    render();
  }
},{passive:false});
work.addEventListener('touchend', e=>{
  if(e.touches.length<2) isTouchPinch=false;
});

// -------------------- SAVE / LOAD --------------------
function saveProject(){
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width=canvasWidth;
  tempCanvas.height=canvasHeight;
  const tctx=tempCanvas.getContext('2d');

  for(let y=0;y<canvasHeight;y++){
    for(let x=0;x<canvasWidth;x++){
      if(pixelData[y][x]){
        tctx.fillStyle=pixelData[y][x];
        tctx.fillRect(x,y,1,1);
      }
    }
  }
  return tempCanvas.toDataURL();
}

function loadProject(base64png){
  const img=new Image();
  img.onload=()=>{
    canvasWidth=img.width;
    canvasHeight=img.height;
    initBuffer(canvasWidth,canvasHeight);
    ctx.drawImage(img,0,0,canvasWidth,canvasHeight);
    render();
  };
  img.src=base64png;
}

document.getElementById('btnOpen').addEventListener('click',()=>{
  const input=document.createElement('input');
  input.type='file';
  input.accept='image/*';
  input.onchange=()=>{
    const file=input.files[0];
    if(!file) return;
    const url=URL.createObjectURL(file);
    loadProject(url);
  };
  input.click();
});

document.getElementById('btnSave').addEventListener('click',()=>{
  const dataUrl=saveProject();
  const a=document.createElement('a');
  a.href=dataUrl;
  a.download='pixelart.png';
  a.click();
});
</script>
</body>
</html>
