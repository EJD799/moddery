<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mini Canvas Editor â€” Full Fixed Example</title>
  <link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-family: Verdana, sans-serif;
      background: #222;
      cursor: default;
    }
    #editorRoot {
      width: 100%;
      height: 100%;
    }
    .mce-workspace canvas {
      cursor: crosshair !important;
    }
  </style>
</head>
<body>
<div id="editorRoot"></div>

<script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>

<script>
const editor = miniCanvasEditor.Editor.createBlank(
  document.getElementById('editorRoot'),
  window.innerWidth,
  window.innerHeight,
  {}
);
const canvas = editor.canvas;
const fabric = canvas.fabric;

// --- Add sample rectangle and text ---
const rect = new fabric.Rect({
  left: 200, top: 200, width: 200, height: 150,
  fill: '#00aaff', stroke: '#0077cc', strokeWidth: 2
});
const text = new fabric.Textbox('Editable Verdana Text', {
  left: 500, top: 250, width: 300, fontSize: 28,
  fill: '#ffffff', fontFamily: 'Verdana'
});
canvas.add(rect, text);
canvas.setActiveObject(text);
canvas.requestRenderAll();

// --- Keep rectangle tool active ---
editor.currentTool = 'rect';
const originalSetMode = editor.setMode.bind(editor);
editor.setMode = mode => {
  originalSetMode(mode);
  editor.currentTool = mode;
};
const originalAddObject = canvas.add.bind(canvas);
canvas.add = (...args) => {
  const result = originalAddObject(...args);
  if (editor.currentTool) editor.setMode(editor.currentTool);
  return result;
};

// --- Pan & zoom ---
let isPanning = false, lastX = 0, lastY = 0, raf = null;
const PAN_SPEED = 0.6;
const ZOOM_FACTOR = 1.02;

function updateViewport(dx, dy, zoomDelta, pointer) {
  if (zoomDelta !== 0) {
    let zoom = canvas.getZoom() * zoomDelta;
    zoom = Math.max(0.1, Math.min(10, zoom));
    canvas.zoomToPoint(pointer, zoom);
  }
  if (dx !== 0 || dy !== 0) {
    const t = canvas.viewportTransform.slice();
    t[4] += dx;
    t[5] += dy;
    canvas.setViewportTransform(t);
  }
  canvas.requestRenderAll();
}

// Wheel: scroll = pan, ctrl/command or pinch = zoom
canvas.upperCanvasEl.addEventListener('wheel', e => {
  e.preventDefault();
  const pointer = canvas.getPointer(e);
  let dx = 0, dy = 0, zoomDelta = 0;
  const isZoom = e.ctrlKey || e.metaKey || e.scale;

  if (isZoom) {
    zoomDelta = e.deltaY < 0 ? ZOOM_FACTOR : 1 / ZOOM_FACTOR;
  } else {
    dx = -e.deltaX * PAN_SPEED;
    dy = -e.deltaY * PAN_SPEED;
  }

  if (raf) cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => updateViewport(dx, dy, zoomDelta, pointer));
}, { passive: false });

// Drag-to-pan
canvas.on('mouse:down', opt => {
  if (opt.target) return;
  isPanning = true;
  lastX = opt.e.clientX;
  lastY = opt.e.clientY;
  canvas.setCursor('grabbing');
});
canvas.on('mouse:move', opt => {
  if (!isPanning) return;
  const dx = opt.e.clientX - lastX;
  const dy = opt.e.clientY - lastY;
  lastX = opt.e.clientX;
  lastY = opt.e.clientY;
  const t = canvas.viewportTransform.slice();
  t[4] += dx;
  t[5] += dy;
  canvas.setViewportTransform(t);
  canvas.requestRenderAll();
});
canvas.on('mouse:up', () => {
  isPanning = false;
  canvas.setCursor('crosshair');
});

// --- Keyboard shortcuts ---
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  const el = document.activeElement;
  const tag = el?.tagName;
  const activeObj = canvas.getActiveObject?.();
  const moveStep = 5;
  const isEditing =
    (activeObj?.type === 'textbox' && activeObj.isEditing) ||
    el?.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA';

  if (isEditing) return;

  // Undo / redo
  if ((e.ctrlKey || e.metaKey) && !e.shiftKey && key === 'z') { e.preventDefault(); editor.undo?.(); return; }
  if ((e.ctrlKey || e.metaKey) && (key === 'y' || (e.shiftKey && key === 'z'))) { e.preventDefault(); editor.redo?.(); return; }

  // Delete / backspace
  if ((key === 'delete' || key === 'backspace') && activeObj) {
    e.preventDefault();
    canvas.remove(activeObj);
    canvas.discardActiveObject();
    canvas.requestRenderAll();
    return;
  }

  // Arrow keys
  if (activeObj) {
    e.preventDefault();
    switch(key) {
      case 'arrowup': activeObj.top -= moveStep; break;
      case 'arrowdown': activeObj.top += moveStep; break;
      case 'arrowleft': activeObj.left -= moveStep; break;
      case 'arrowright': activeObj.left += moveStep; break;
    }
    activeObj.setCoords();
    canvas.requestRenderAll();
  }
});

// --- Resize ---
window.addEventListener('resize', () => {
  editor.resize(window.innerWidth, window.innerHeight);
  canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
  canvas.requestRenderAll();
});
</script>
</body>
</html>
