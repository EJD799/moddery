<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Canvas Editor â€” Zoom & Pan</title>
<link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
<style>
  html, body {
    margin:0; padding:0; width:100%; height:100%; overflow:hidden;
    font-family: Verdana, sans-serif; background:#222; color:#fff;
  }
  #editorRoot { width:100%; height:100%; }
  /* Crosshair cursor inside canvas */
  .mce-workspace canvas { cursor: crosshair !important; }
</style>
</head>
<body>
<div id="editorRoot"></div>

<script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>

<script>
  const editor = miniCanvasEditor.Editor.createBlank(
    document.getElementById('editorRoot'),
    window.innerWidth,
    window.innerHeight,
    {
      textOptions: { fontFamily: 'Verdana', fill: '#ffffff', fontSize: 24 },
      keyboard: { delete: true, undo: true, redo: true, arrowMoveStep: 5 }
    }
  );

  const canvas = editor.canvas; // built-in canvas object

  // --- Zoom & Pan variables ---
  const ZOOM_SPEED = 1.03; // slower zoom per wheel tick
  let isPanning = false, lastX = 0, lastY = 0;

  // Wheel: pinch/trackpad zoom, normal scroll pan
  canvas.upperCanvasEl.addEventListener('wheel', e => {
    e.preventDefault();
    const pointer = canvas.getPointer(e);

    if (e.ctrlKey || e.metaKey || e.scale) {
      // Zoom (slower)
      const delta = e.deltaY < 0 ? ZOOM_SPEED : 1 / ZOOM_SPEED;
      canvas.zoomToPoint(pointer, canvas.getZoom() * delta);
    } else {
      // Scroll-to-pan
      const t = canvas.viewportTransform.slice();
      t[4] -= e.deltaX;
      t[5] -= e.deltaY;
      canvas.setViewportTransform(t);
      canvas.requestRenderAll();
    }
  }, { passive: false });

  // Cmd/Ctrl + drag to pan
  canvas.on('mouse:down', opt => {
    if ((opt.e.metaKey || opt.e.ctrlKey) && !opt.target) {
      isPanning = true;
      lastX = opt.e.clientX;
      lastY = opt.e.clientY;
      canvas.setCursor('grabbing');
    }
  });
  canvas.on('mouse:move', opt => {
    if (!isPanning) return;
    const dx = opt.e.clientX - lastX;
    const dy = opt.e.clientY - lastY;
    lastX = opt.e.clientX;
    lastY = opt.e.clientY;
    const t = canvas.viewportTransform.slice();
    t[4] += dx;
    t[5] += dy;
    canvas.setViewportTransform(t);
    canvas.requestRenderAll();
  });
  canvas.on('mouse:up', () => {
    isPanning = false;
    canvas.setCursor('crosshair');
  });

  // --- Window resize ---
  window.addEventListener('resize', () => {
    editor.resize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
