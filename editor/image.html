<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Canvas Editor â€” Full Example</title>
<link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; font-family: Verdana, sans-serif; background:#222; }
  #editorRoot { width:100%; height:100%; }
  /* Canvas cursor */
  .mce-workspace canvas { cursor: crosshair !important; }
</style>
</head>
<body>
<div id="editorRoot"></div>

<!-- Load Fabric.js first -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/6.0.0-beta.14/fabric.min.js"></script>

<!-- Load Mini Canvas Editor -->
<script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>

<script>
  // --- Create blank editor filling window ---
  const editor = miniCanvasEditor.Editor.createBlank(
    document.getElementById('editorRoot'),
    window.innerWidth,
    window.innerHeight,
    {
      textOptions: { fontFamily: 'Verdana', fill: '#ffffff', fontSize: 20 },
      keyboard: { delete: true, undo: true, redo: true, arrowMoveStep: 5 }
    }
  );

  const canvas = editor.canvas.fabric; // access the internal Fabric canvas

  // --- Smooth zoom/pan ---
  const ZOOM_STEP = 1.05;  // zoom per tick
  const PAN_SPEED = 0.5;   // scroll-to-pan speed
  let isPanning = false, lastX = 0, lastY = 0;

  const upperCanvas = canvas.upperCanvasEl;

  // Wheel: ctrl/cmd or pinch = zoom, normal scroll = pan
  upperCanvas.addEventListener('wheel', e => {
    e.preventDefault();
    const pointer = canvas.getPointer(e);

    if (e.ctrlKey || e.metaKey || e.scale) {
      // Zoom
      const delta = e.deltaY < 0 ? ZOOM_STEP : 1 / ZOOM_STEP;
      canvas.zoomToPoint(pointer, canvas.getZoom() * delta);
    } else {
      // Scroll-to-pan
      const t = canvas.viewportTransform.slice();
      t[4] -= e.deltaX * PAN_SPEED;
      t[5] -= e.deltaY * PAN_SPEED;
      canvas.setViewportTransform(t);
      canvas.requestRenderAll();
    }
  }, { passive: false });

  // Drag-to-pan when clicking empty canvas
  canvas.on('mouse:down', opt => {
    if (!opt.target) {
      isPanning = true;
      lastX = opt.e.clientX;
      lastY = opt.e.clientY;
      canvas.setCursor('grabbing');
    }
  });
  canvas.on('mouse:move', opt => {
    if (!isPanning) return;
    const dx = opt.e.clientX - lastX;
    const dy = opt.e.clientY - lastY;
    lastX = opt.e.clientX;
    lastY = opt.e.clientY;

    const t = canvas.viewportTransform.slice();
    t[4] += dx;
    t[5] += dy;
    canvas.setViewportTransform(t);
    canvas.requestRenderAll();
  });
  canvas.on('mouse:up', () => {
    isPanning = false;
    canvas.setCursor('crosshair');
  });

  // --- Handle window resize ---
  window.addEventListener('resize', () => {
    editor.resize(window.innerWidth, window.innerHeight);
    canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
    canvas.requestRenderAll();
  });

  // --- Optional: Keep selected tool active (rectangle/text) ---
  editor.onToolChanged = tool => {
    editor.currentTool = tool;
  };
</script>
</body>
</html>
