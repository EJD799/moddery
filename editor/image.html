<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Art Editor</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" crossorigin="anonymous" />
<style>
html, body {
    margin: 0; padding: 0; height: 100%;
    font-family: Verdana, sans-serif; background: #111; color: #fff;
    display: flex; flex-direction: column;
}
#toolbar {
    display: flex; gap: 4px; padding: 4px; background: #222;
    align-items: center; flex-wrap: wrap;
}
#toolbar button {
    display: flex; align-items: center; gap: 4px;
    padding: 4px 8px; background: #333; color: #fff; border: none; cursor: pointer;
}
#toolbar button.active { background: #555; }
#toolbar input[type=color], #toolbar input[type=range] { margin-left: 4px; }
#canvasContainer {
    flex: 1; position: relative; overflow: hidden; background: #222;
    display: flex; justify-content: center; align-items: center; cursor: crosshair;
}
canvas { image-rendering: pixelated; display: block; }
</style>
</head>
<body>

<div id="toolbar">
    <button id="toolPencil" class="active"><i class="fas fa-pencil-alt"></i>Pencil</button>
    <button id="toolRect"><i class="fas fa-square"></i>Rectangle</button>
    <button id="toolFill"><i class="fas fa-fill-drip"></i>Fill</button>
    <button id="toolEraser"><i class="fas fa-eraser"></i>Eraser</button>
    <button id="toolEyedropper"><i class="fas fa-eye-dropper"></i>Eyedropper</button>
    <button id="toolHueBrush"><i class="fas fa-adjust"></i>Hue Brush</button>
    <button id="toolText"><i class="fas fa-font"></i>Text</button>
    <label>Color:<input type="color" id="colorPicker" value="#ff0000"></label>
    <label>Brush Size:<input type="range" id="brushSize" min="1" max="16" value="1"></label>
    <button id="undoBtn"><i class="fas fa-undo"></i>Undo</button>
    <button id="redoBtn"><i class="fas fa-redo"></i>Redo</button>
</div>

<div id="canvasContainer">
    <canvas id="pixelCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');

let gridWidth = 64, gridHeight = 64;
let pixelSize = 16;
let brushSize = 1;
let currentTool = 'pencil';
let currentColor = '#ff0000';
let isDrawing = false;
let offsetX = 0, offsetY = 0;
let scale = 1;
let lastMouseEvent = null;

// Pixel data canvas
const bgCanvas = document.createElement('canvas');
const bgCtx = bgCanvas.getContext('2d');
bgCanvas.width = gridWidth;
bgCanvas.height = gridHeight;

// Undo/Redo
let undoStack = [], redoStack = [];
function saveState() {
    redoStack = [];
    undoStack.push(bgCtx.getImageData(0, 0, gridWidth, gridHeight));
    if (undoStack.length > 50) undoStack.shift();
}
function undo() {
    if (undoStack.length) {
        redoStack.push(bgCtx.getImageData(0, 0, gridWidth, gridHeight));
        bgCtx.putImageData(undoStack.pop(), 0, 0);
        render();
    }
}
function redo() {
    if (redoStack.length) {
        undoStack.push(bgCtx.getImageData(0, 0, gridWidth, gridHeight));
        bgCtx.putImageData(redoStack.pop(), 0, 0);
        render();
    }
}
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// Checkerboard pattern (does not scale with zoom)
const checkerCanvas = document.createElement('canvas');
checkerCanvas.width = 16;
checkerCanvas.height = 16;
const checkerCtx = checkerCanvas.getContext('2d');
checkerCtx.fillStyle = '#ccc'; checkerCtx.fillRect(0, 0, 8, 8); checkerCtx.fillRect(8, 8, 8, 8);
checkerCtx.fillStyle = '#fff'; checkerCtx.fillRect(8, 0, 8, 8); checkerCtx.fillRect(0, 8, 8, 8);
const checkerPattern = ctx.createPattern(checkerCanvas, 'repeat');

// Helper: color conversion
function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) { h = s = 0; }
    else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h *= 60;
    }
    return [h, s, l];
}
function hslToRgb(h, s, l) {
    h /= 360;
    let r, g, b;
    if (s === 0) { r = g = b = l; }
    else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [r * 255, g * 255, b * 255];
}

// Color utils
function colorToRGBA(str) {
    const c = document.createElement('canvas').getContext('2d');
    c.fillStyle = str;
    c.fillRect(0, 0, 1, 1);
    return c.getImageData(0, 0, 1, 1).data;
}

// âœ… Fixed hue brush implementation
function drawPixel(x, y, mode) {
    const half = Math.floor(brushSize / 2);
    if (mode === 'eraser') {
        bgCtx.clearRect(x - half, y - half, brushSize, brushSize);
    } else if (mode === 'hue') {
        const imgData = bgCtx.getImageData(x - half, y - half, brushSize, brushSize);
        const data = imgData.data;
        const targetRGBA = colorToRGBA(currentColor);
        const targetHSL = rgbToHsl(targetRGBA[0], targetRGBA[1], targetRGBA[2]);
        for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] === 0) continue;
            const srcHSL = rgbToHsl(data[i], data[i + 1], data[i + 2]);
            const newRGB = hslToRgb(targetHSL[0], srcHSL[1], srcHSL[2]);
            data[i] = newRGB[0];
            data[i + 1] = newRGB[1];
            data[i + 2] = newRGB[2];
        }
        bgCtx.putImageData(imgData, x - half, y - half);
    } else {
        bgCtx.fillStyle = (mode === 'pencil') ? currentColor : mode;
        bgCtx.fillRect(x - half, y - half, brushSize, brushSize);
    }
}

// Mouse coordinate conversion
function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / (pixelSize * scale);
    const y = (e.clientY - rect.top - offsetY) / (pixelSize * scale);
    return { x: Math.floor(x), y: Math.floor(y) };
}

// Render loop
function render() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = checkerPattern;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale * pixelSize, scale * pixelSize);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(bgCanvas, 0, 0);
    ctx.restore();
}

// Resize
function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    render();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Zoom centered at mouse
container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const worldX = (mx - offsetX) / (pixelSize * scale);
    const worldY = (my - offsetY) / (pixelSize * scale);
    scale = Math.min(Math.max(scale * zoomFactor, 0.06), 64);
    offsetX = mx - worldX * (pixelSize * scale);
    offsetY = my - worldY * (pixelSize * scale);
    render();
});

// Mouse events
canvas.addEventListener('mousedown', (e) => {
    isDrawing = true;
    const pos = getMousePos(e);
    saveState();
    drawPixel(pos.x, pos.y, currentTool);
    render();
});
canvas.addEventListener('mousemove', (e) => {
    if (!isDrawing) return;
    const pos = getMousePos(e);
    drawPixel(pos.x, pos.y, currentTool);
    render();
});
canvas.addEventListener('mouseup', () => isDrawing = false);
canvas.addEventListener('mouseleave', () => isDrawing = false);

// Tool and color selectors
document.getElementById('colorPicker').oninput = e => currentColor = e.target.value;
document.getElementById('brushSize').oninput = e => brushSize = parseInt(e.target.value);
document.querySelectorAll('#toolbar button').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('#toolbar button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.id.replace('tool', '').toLowerCase();
    });
});
</script>
</body>
</html>
