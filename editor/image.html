<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Art Editor with Zoom, Pan, Eyedropper</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" crossorigin="anonymous" />
<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: Verdana, sans-serif;
    background: #222;
    color: #fff;
}
#toolbar {
    display: flex;
    gap: 4px;
    padding: 4px;
    background: #333;
    align-items: center;
    flex-wrap: wrap;
}
#toolbar button {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    background: #444;
    color: #fff;
    border: none;
    cursor: pointer;
}
#toolbar button.active {
    background: #666;
}
#toolbar input[type=color],
#toolbar input[type=range] {
    margin-left: 4px;
}
#canvasContainer {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: #111;
    cursor: crosshair;
    display: flex;
    justify-content: center;
    align-items: center;
}
canvas {
    image-rendering: pixelated;
    background: transparent;
    display: block;
}
</style>
</head>
<body>

<div id="toolbar">
    <button id="toolPencil" class="active"><i class="fas fa-pencil-alt"></i>Pencil</button>
    <button id="toolRect"><i class="fas fa-square"></i>Rectangle</button>
    <button id="toolFill"><i class="fas fa-fill-drip"></i>Fill</button>
    <button id="toolEraser"><i class="fas fa-eraser"></i>Eraser</button>
    <button id="toolEyedropper"><i class="fas fa-eye-dropper"></i>Eyedropper</button>
    <label>Color:<input type="color" id="colorPicker" value="#ff0000"></label>
    <label>Pixel Size:<input type="range" id="pixelSize" min="4" max="64" value="16"></label>
    <button id="undoBtn"><i class="fas fa-undo"></i>Undo</button>
    <button id="redoBtn"><i class="fas fa-redo"></i>Redo</button>
    <button id="saveBtn"><i class="fas fa-download"></i>Save</button>
    <button id="loadBtn"><i class="fas fa-upload"></i>Load</button>
    <input type="file" id="fileInput" style="display:none">
</div>

<div id="canvasContainer">
    <canvas id="pixelCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');

let gridWidth = 32, gridHeight = 32; // can support larger images
let pixelSize = 16;
let currentTool = 'pencil';
let currentColor = '#ff0000';
let isDrawing = false;
let startX = 0, startY = 0;

// Camera for zoom/pan
let offsetX = 0, offsetY = 0;
let scale = 1;

// Offscreen background canvas for pixels
const bgCanvas = document.createElement('canvas');
bgCanvas.width = gridWidth;
bgCanvas.height = gridHeight;
const bgCtx = bgCanvas.getContext('2d');
bgCtx.clearRect(0,0,gridWidth,gridHeight);

// Undo/Redo
let undoStack = [], redoStack = [];
function saveState(){redoStack=[]; undoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight)); if(undoStack.length>50) undoStack.shift();}
function undo(){if(undoStack.length){redoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight)); bgCtx.putImageData(undoStack.pop(),0,0); render();}}
function redo(){if(redoStack.length){undoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight)); bgCtx.putImageData(redoStack.pop(),0,0); render();}}

// Resize canvas
function resizeCanvas(){canvas.width=container.clientWidth; canvas.height=container.clientHeight; render();}

// Get mouse pos in pixel coords
function getMousePos(e){
    const rect=canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / (pixelSize*scale);
    const y = (e.clientY - rect.top - offsetY) / (pixelSize*scale);
    return {x: Math.floor(x), y: Math.floor(y)};
}

// Draw pixel
function drawPixel(x,y,color){bgCtx.fillStyle=color; bgCtx.fillRect(x,y,1,1); render();}

// Flood fill
function floodFill(x,y,color){
    const data=bgCtx.getImageData(0,0,gridWidth,gridHeight);
    const targetColor=[...data.data.slice((y*gridWidth+x)*4,(y*gridWidth+x)*4+4)];
    const fillColor=colorToRGBA(color);
    if(targetColor.every((v,i)=>v===fillColor[i])) return;
    const stack=[[x,y]];
    while(stack.length){
        const [cx,cy]=stack.pop();
        if(cx<0||cy<0||cx>=gridWidth||cy>=gridHeight) continue;
        const idx=(cy*gridWidth+cx)*4;
        if(data.data[idx]!==targetColor[0]||data.data[idx+1]!==targetColor[1]||data.data[idx+2]!==targetColor[2]||data.data[idx+3]!==targetColor[3]) continue;
        data.data[idx]=fillColor[0]; data.data[idx+1]=fillColor[1]; data.data[idx+2]=fillColor[2]; data.data[idx+3]=fillColor[3];
        stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
    }
    bgCtx.putImageData(data,0,0); render();
}

// Draw rectangle
function drawRect(x1,y1,x2,y2,color){
    const xmin=Math.min(x1,x2), xmax=Math.max(x1,x2), ymin=Math.min(y1,y2), ymax=Math.max(y1,y2);
    for(let x=xmin;x<=xmax;x++) for(let y=ymin;y<=ymax;y++) drawPixel(x,y,color);
}

// Convert color string to RGBA
function colorToRGBA(str){
    const c=document.createElement('canvas').getContext('2d'); c.fillStyle=str; c.fillRect(0,0,1,1);
    return c.getImageData(0,0,1,1).data;
}

// Render function
let renderScheduled=false, previewRect=null;
function render(){
    if(renderScheduled) return;
    renderScheduled=true;
    requestAnimationFrame(()=>{
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.translate(offsetX,offsetY);
        ctx.scale(scale*pixelSize,scale*pixelSize);
        ctx.imageSmoothingEnabled=false;
        ctx.drawImage(bgCanvas,0,0,gridWidth,gridHeight,0,0,gridWidth,gridHeight);

        // rectangle preview
        if(previewRect){
            ctx.fillStyle = currentColor+'55';
            ctx.fillRect(previewRect.x, previewRect.y, previewRect.w, previewRect.h);
            ctx.strokeStyle=currentColor;
            ctx.lineWidth=1/scale/pixelSize;
            ctx.strokeRect(previewRect.x, previewRect.y, previewRect.w, previewRect.h);
        }

        renderScheduled=false;
    });
}

// Mouse events
canvas.addEventListener('mousedown', e=>{
    const pos=getMousePos(e);
    startX=pos.x; startY=pos.y; isDrawing=true;
    if(['pencil','eraser','fill','rect'].includes(currentTool)) saveState();

    if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor);
    if(currentTool==='eraser') drawPixel(pos.x,pos.y,'rgba(0,0,0,0)');
    if(currentTool==='fill') floodFill(pos.x,pos.y,currentColor);
    if(currentTool==='eyedropper') currentColor=getPixelColor(pos.x,pos.y);
});

canvas.addEventListener('mousemove', e=>{
    if(!isDrawing) return;
    const pos=getMousePos(e);
    if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor);
    if(currentTool==='eraser') drawPixel(pos.x,pos.y,'rgba(0,0,0,0)');
    if(currentTool==='rect'){
        const x = Math.min(startX,pos.x), y = Math.min(startY,pos.y);
        const w = Math.abs(pos.x-startX)+1, h = Math.abs(pos.y-startY)+1;
        previewRect = {x,y,w,h};
        render();
    }
});

canvas.addEventListener('mouseup', e=>{
    if(currentTool==='rect' && previewRect){
        drawRect(startX,startY,getMousePos(e).x,getMousePos(e).y,currentColor);
        previewRect=null;
    }
    isDrawing=false;
    render();
});

// Eyedropper
function getPixelColor(x,y){
    const data=bgCtx.getImageData(x,y,1,1).data;
    return `rgba(${data[0]},${data[1]},${data[2]},${data[3]/255})`;
}

// Toolbar
const toolButtons={pencil:document.getElementById('toolPencil'),rect:document.getElementById('toolRect'),fill:document.getElementById('toolFill'),eraser:document.getElementById('toolEraser'),eyedropper:document.getElementById('toolEyedropper')};
function selectTool(tool){currentTool=tool; Object.keys(toolButtons).forEach(t=>toolButtons[t].classList.toggle('active',t===tool));}
toolButtons.pencil.onclick=()=>selectTool('pencil');
toolButtons.rect.onclick=()=>selectTool('rect');
toolButtons.fill.onclick=()=>selectTool('fill');
toolButtons.eraser.onclick=()=>selectTool('eraser');
toolButtons.eyedropper.onclick=()=>selectTool('eyedropper');
document.getElementById('colorPicker').onchange=e=>currentColor=e.target.value;
document.getElementById('pixelSize').oninput=e=>{pixelSize=parseInt(e.target.value); resizeCanvas();}
document.getElementById('undoBtn').onclick=undo;
document.getElementById('redoBtn').onclick=redo;

// Zoom & Pan
let isPanning=false, lastX=0, lastY=0;
canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const delta = -e.deltaY*0.0015; // zoom speed
    const mx = e.offsetX - offsetX;
    const my = e.offsetY - offsetY;
    const newScale = Math.min(Math.max(scale*(1+delta),0.5),32);
    offsetX -= mx*(newScale-scale);
    offsetY -= my*(newScale-scale);
    scale=newScale;
    render();
}, {passive:false});

canvas.addEventListener('mousedown', e=>{
    if(e.button===1){isPanning=true; lastX=e.clientX; lastY=e.clientY; canvas.style.cursor='move'; e.preventDefault();}
});
window.addEventListener('mouseup', e=>{isPanning=false; canvas.style.cursor='crosshair';});
window.addEventListener('mousemove', e=>{
    if(isPanning){
        offsetX += e.clientX-lastX;
        offsetY += e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY;
        render();
    }
});

// Save/load
const exportSize = 16;
function saveProject(){const c=document.createElement('canvas'); c.width=exportSize; c.height=exportSize; const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(bgCanvas,0,0,exportSize,exportSize); return c.toDataURL('image/png');}
function loadProject(base64){const img=new Image(); img.onload=()=>{bgCtx.clearRect(0,0,gridWidth,gridHeight); bgCtx.drawImage(img,0,0,gridWidth,gridHeight); render();}; img.src=base64;}
document.getElementById('saveBtn').onclick=()=>{const data=saveProject(); const a=document.createElement('a'); a.href=data; a.download='pixel.png'; a.click();}
document.getElementById('loadBtn').onclick=()=>{document.getElementById('fileInput').click();}
document.getElementById('fileInput').onchange=e=>{
    const f=e.target.files[0]; if(!f) return;
    const reader=new FileReader();
    reader.onload = evt=>loadProject(evt.target.result);
    reader.readAsDataURL(f);
}

// Initial
resizeCanvas();
window.addEventListener('resize',resizeCanvas);
</script>
</body>
</html>
