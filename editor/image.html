<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mini Canvas Editor — Blank Canvas Example</title>

  <!-- Mini Canvas Editor (UMD build) -->
  <link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>

  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #222;
      color: #fff;
      font-family: sans-serif;
    }
    #toolbar {
      padding: 8px;
      background: #111;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #work {
      flex: 1;
      overflow: hidden;
      background: #333;
      position: relative;
      cursor: grab;
    }
    #placeholder {
      width: 1200px;
      height: 800px;
      margin: 40px auto;
      border: 1px solid #555;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="btnAddText">Add Text</button>
    <button id="btnUndo">Undo</button>
    <button id="btnRedo">Redo</button>
    <button id="btnReset">Reset view</button>
    <span style="opacity:.7; margin-left:10px;">Scroll = Pan | Ctrl+Scroll = Zoom | Backspace/Delete = Remove Object</span>
  </div>

  <div id="work">
    <div id="placeholder"></div>
  </div>

  <script>
    window.addEventListener('load', () => {
      const MCE = window.MiniCanvasEditor || window.miniCanvasEditor || window.miniCanvas;
      if (!MCE) {
        alert("MiniCanvasEditor global not found!");
        return;
      }

      const placeholder = document.getElementById('placeholder');
      const editorInstance = MCE.Editor.createBlank(placeholder, 1200, 800, {});
      const canvas = editorInstance.workspace.canvas;
      const fabric = window.fabric;

      console.log("✅ Blank editor ready", editorInstance);

      // --- Add Text ---
      document.getElementById('btnAddText').addEventListener('click', () => {
        const text = new fabric.Textbox('Type here', {
          left: 100,
          top: 100,
          fill: '#fff',
          fontSize: 24,
          editable: true
        });
        canvas.add(text);
        canvas.setActiveObject(text);
        canvas.requestRenderAll();
      });

      // --- Undo / Redo ---
      document.getElementById('btnUndo').addEventListener('click', () => {
        if (editorInstance.history?.undo) editorInstance.history.undo();
      });
      document.getElementById('btnRedo').addEventListener('click', () => {
        if (editorInstance.history?.redo) editorInstance.history.redo();
      });

      // --- Reset view ---
      document.getElementById('btnReset').addEventListener('click', () => {
        canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
        canvas.setZoom(1);
        canvas.requestRenderAll();
      });

      // --- Keyboard shortcuts ---
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        const active = canvas.getActiveObject();

        // ignore typing in textboxes
        if (active && active.type === 'textbox' && active.isEditing) return;

        if ((e.ctrlKey || e.metaKey) && key === 'z') {
          e.preventDefault();
          editorInstance.history?.undo();
        }
        if ((e.ctrlKey || e.metaKey) && (key === 'y' || (e.shiftKey && key === 'z'))) {
          e.preventDefault();
          editorInstance.history?.redo();
        }
        if (key === 'backspace' || key === 'delete') {
          e.preventDefault();
          if (active) {
            canvas.remove(active);
            canvas.discardActiveObject();
            canvas.requestRenderAll();
          }
        }
      });

      // --- Zoom and Pan ---
      const work = document.getElementById('work');
      let isDragging = false, lastX = 0, lastY = 0;

      work.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
          const zoom = canvas.getZoom() * (e.deltaY < 0 ? 1.1 : 0.9);
          canvas.zoomToPoint({ x: e.offsetX, y: e.offsetY }, Math.min(Math.max(zoom, 0.1), 10));
        } else {
          const t = canvas.viewportTransform;
          t[4] -= e.deltaX;
          t[5] -= e.deltaY;
          canvas.setViewportTransform(t);
          canvas.requestRenderAll();
        }
      }, { passive: false });

      work.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        work.style.cursor = 'grabbing';
      });
      window.addEventListener('mouseup', () => {
        isDragging = false;
        work.style.cursor = 'grab';
      });
      work.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        const t = canvas.viewportTransform;
        t[4] += dx;
        t[5] += dy;
        canvas.setViewportTransform(t);
        canvas.requestRenderAll();
      });
    });
  </script>
</body>
</html>
