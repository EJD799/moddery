<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini Canvas Editor â€” Fixed Full Example</title>
  <link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: Verdana, sans-serif;
      background: #222;
      cursor: default;
    }
    #editorRoot {
      width: 100%;
      height: 100%;
    }
    /* Canvas cursor */
    .mce-workspace canvas {
      cursor: crosshair !important;
    }
  </style>
</head>
<body>
<div id="editorRoot"></div>

<script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>
<script>
  // --- Create blank editor filling the window ---
  const editor = miniCanvasEditor.Editor.createBlank(
    document.getElementById('editorRoot'),
    window.innerWidth,
    window.innerHeight,
    {
      // default text style
      textOptions: { fontFamily: 'Verdana', fill: '#ffffff', fontSize: 20 },
      panSpeed: 0.6,
      zoomFactor: 1.05,
      keyboard: { delete: true, undo: true, redo: true, arrowMoveStep: 5 }
    }
  );
  const canvas = editor.canvas;

  // --- Smooth zoom / pan ---
  const ZOOM_STEP = 1.06;
  const PAN_SPEED = 0.6;
  let isPanning = false, lastX = 0, lastY = 0;

  // Wheel: scroll = pan, ctrl/command or pinch = zoom
  canvas.upperCanvasEl.addEventListener('wheel', e => {
    e.preventDefault();
    const pointer = canvas.getPointer(e);
    if (e.ctrlKey || e.metaKey || e.scale) {
      // zoom
      const delta = e.deltaY < 0 ? ZOOM_STEP : 1 / ZOOM_STEP;
      canvas.zoomToPoint(pointer, canvas.getZoom() * delta);
    } else {
      // scroll to pan
      const t = canvas.viewportTransform.slice();
      t[4] -= e.deltaX * PAN_SPEED;
      t[5] -= e.deltaY * PAN_SPEED;
      canvas.setViewportTransform(t);
      canvas.requestRenderAll();
    }
  }, { passive: false });

  // Drag-to-pan
  canvas.on('mouse:down', opt => {
    if (!opt.target) {
      isPanning = true;
      lastX = opt.e.clientX;
      lastY = opt.e.clientY;
      canvas.setCursor('grabbing');
    }
  });
  canvas.on('mouse:move', opt => {
    if (!isPanning) return;
    const dx = opt.e.clientX - lastX;
    const dy = opt.e.clientY - lastY;
    lastX = opt.e.clientX;
    lastY = opt.e.clientY;

    const t = canvas.viewportTransform.slice();
    t[4] += dx;
    t[5] += dy;
    canvas.setViewportTransform(t);
    canvas.requestRenderAll();
  });
  canvas.on('mouse:up', () => {
    isPanning = false;
    canvas.setCursor('crosshair');
  });

  // --- Resize canvas when window resizes ---
  window.addEventListener('resize', () => {
    editor.resize(window.innerWidth, window.innerHeight);
    canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
    canvas.requestRenderAll();
  });

  // --- Optional: keep toolbar tools active (rectangle/text stays selected until changed) ---
  editor.onToolChanged = tool => {
    editor.currentTool = tool;
  };

</script>
</body>
</html>
