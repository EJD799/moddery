<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mini Canvas Editor â€” Fixed Fullscreen</title>

  <link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      font-family: Verdana, sans-serif;
    }
    #editorRoot {
      width: 100%;
      height: 100%;
      cursor: default;
    }
    /* Cursor fix: crosshair inside canvas only */
    .mce-workspace canvas {
      cursor: crosshair !important;
    }
  </style>
</head>
<body>
  <div id="editorRoot"></div>

  <script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>

  <script>
    // Create editor in fullscreen container
    const root = document.getElementById('editorRoot');
    const editor = miniCanvasEditor.Editor.createBlank(root, window.innerWidth, window.innerHeight, {});

    // Get Fabric canvas
    const canvas = editor.canvas || editor.editor?.canvas || editor.workspace?.canvas;

    // --- Fix invisible text + font ---
    if (window.fabric) {
      fabric.Textbox.prototype.initialize = (function (original) {
        return function (...args) {
          original.apply(this, args);
          this.set({
            fontFamily: 'Verdana',
            fill: '#ffffff',
            fontSize: 20
          });
        };
      })(fabric.Textbox.prototype.initialize);
    }

    // --- Smooth zoom + scroll-pan ---
    let isPanning = false;
    let lastX = 0, lastY = 0;

    // Scroll/pinch = zoom
    canvas.upperCanvasEl.addEventListener('wheel', e => {
      e.preventDefault();
      const pointer = canvas.getPointer(e);
      const zoomDelta = e.deltaY < 0 ? 1.2 : 1 / 1.2;
      const oldZoom = canvas.getZoom();
      let newZoom = oldZoom * zoomDelta;
      newZoom = Math.max(0.1, Math.min(10, newZoom));
      canvas.zoomToPoint({ x: pointer.x, y: pointer.y }, newZoom);
      canvas.requestRenderAll();
    }, { passive: false });

    // Two-finger drag or middle mouse = pan
    canvas.upperCanvasEl.addEventListener('mousedown', e => {
      if (e.button === 1 || e.ctrlKey || e.metaKey) {
        isPanning = true;
        lastX = e.clientX;
        lastY = e.clientY;
        e.preventDefault();
      }
    });
    window.addEventListener('mouseup', () => isPanning = false);
    canvas.upperCanvasEl.addEventListener('mousemove', e => {
      if (!isPanning) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      const t = canvas.viewportTransform.slice();
      t[4] += dx;
      t[5] += dy;
      canvas.setViewportTransform(t);
      canvas.requestRenderAll();
    });

    // --- Keep rectangle tool active ---
    const originalSetMode = editor.setMode.bind(editor);
    editor.setMode = (mode) => {
      originalSetMode(mode);
      editor.currentTool = mode;
    };

    // Prevent auto-reset to move tool
    const originalAddObject = canvas.add.bind(canvas);
    canvas.add = (...args) => {
      const result = originalAddObject(...args);
      if (editor.currentTool) editor.setMode(editor.currentTool);
      return result;
    };

    // Resize canvas when window resizes
    window.addEventListener('resize', () => {
      canvas.setWidth(window.innerWidth);
      canvas.setHeight(window.innerHeight);
      canvas.requestRenderAll();
    });
  </script>
</body>
</html>
