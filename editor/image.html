<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mini Canvas Editor â€” Fixed Fullscreen</title>
  <link href="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/css/editor.css" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      font-family: Verdana, sans-serif;
      cursor: default;
    }
    #editorRoot {
      width: 100%;
      height: 100%;
    }
    .mce-workspace canvas {
      cursor: crosshair !important;
    }
  </style>
</head>
<body>
<div id="editorRoot"></div>

<script src="https://cdn.jsdelivr.net/npm/mini-canvas-core@0.3.2/dist/index.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mini-canvas-editor@0.3.2/dist/index.umd.js"></script>

<script>
const editor = miniCanvasEditor.Editor.createBlank(
  document.getElementById('editorRoot'),
  window.innerWidth,
  window.innerHeight,
  {}
);
const canvas = editor.canvas || editor.editor?.canvas || editor.workspace?.canvas;
const fabric = window.fabric;

// --- Fix invisible textboxes ---
if (fabric) {
  const originalInit = fabric.Textbox.prototype.initialize;
  fabric.Textbox.prototype.initialize = function(...args) {
    originalInit.apply(this, args);
    this.set({ fontFamily: 'Verdana', fill: '#ffffff', fontSize: 20 });
    this.setCoords();
  };
}

// --- Add example objects (optional) ---
const rect = new fabric.Rect({ left: 200, top: 200, width: 200, height: 150, fill: '#00aaff', stroke: '#0077cc', strokeWidth: 2 });
const text = new fabric.Textbox('Editable Verdana Text', { left: 500, top: 250, width: 300, fontSize: 28 });
canvas.add(rect, text);

// --- Persistent rectangle tool ---
editor.currentTool = 'rect';
const originalSetMode = editor.setMode.bind(editor);
editor.setMode = mode => {
  originalSetMode(mode);
  editor.currentTool = mode;
};
const originalAddObject = canvas.add.bind(canvas);
canvas.add = (...args) => {
  const result = originalAddObject(...args);
  if (editor.currentTool) editor.setMode(editor.currentTool);
  return result;
};

// --- Zoom & pan ---
let isPanning = false, lastX = 0, lastY = 0, raf = null;
const PAN_SPEED = 0.6;
const ZOOM_FACTOR = 1.02;

function updateViewport(dx, dy, zoomDelta, pointer) {
  if (zoomDelta !== 0) {
    let zoom = canvas.getZoom() * zoomDelta;
    zoom = Math.max(0.1, Math.min(10, zoom));
    canvas.zoomToPoint(pointer, zoom);
  }
  if (dx !== 0 || dy !== 0) {
    const t = canvas.viewportTransform.slice();
    t[4] += dx;
    t[5] += dy;
    canvas.setViewportTransform(t);
  }
  canvas.requestRenderAll();
}

// Wheel = pan normally, ctrl/cmd = zoom
canvas.upperCanvasEl.addEventListener('wheel', e => {
  e.preventDefault();
  const pointer = canvas.getPointer(e);
  let dx = 0, dy = 0, zoomDelta = 0;
  const isZoom = e.ctrlKey || e.metaKey || e.scale;

  if (isZoom) {
    zoomDelta = e.deltaY < 0 ? ZOOM_FACTOR : 1 / ZOOM_FACTOR;
  } else {
    dx = -e.deltaX * PAN_SPEED;
    dy = -e.deltaY * PAN_SPEED;
  }

  if (raf) cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => updateViewport(dx, dy, zoomDelta, pointer));
}, { passive: false });

// Drag to pan
canvas.on('mouse:down', opt => {
  if (opt.target) return;
  isPanning = true;
  lastX = opt.e.clientX;
  lastY = opt.e.clientY;
  canvas.setCursor('grabbing');
});
canvas.on('mouse:move', opt => {
  if (!isPanning) return;
  const dx = opt.e.clientX - lastX;
  const dy = opt.e.clientY - lastY;
  lastX = opt.e.clientX;
  lastY = opt.e.clientY;
  const t = canvas.viewportTransform.slice();
  t[4] += dx;
  t[5] += dy;
  canvas.setViewportTransform(t);
  canvas.requestRenderAll();
});
canvas.on('mouse:up', () => {
  isPanning = false;
  canvas.setCursor('crosshair');
});

// --- Keyboard handling ---
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  const el = document.activeElement;
  const tag = el?.tagName;
  const isEditing =
    (canvas.getActiveObject()?.type === 'textbox' && canvas.getActiveObject().isEditing) ||
    el?.isContentEditable ||
    tag === 'INPUT' || tag === 'TEXTAREA' ||
    el?.getAttribute('role') === 'textbox';

  if (isEditing) return;

  const activeObj = canvas.getActiveObject?.();
  const moveStep = 5;

  // Undo/Redo
  if ((e.ctrlKey || e.metaKey) && !e.shiftKey && key === 'z') { e.preventDefault(); editor.undo?.(); return; }
  if ((e.ctrlKey || e.metaKey) && (key === 'y' || (e.shiftKey && key === 'z'))) { e.preventDefault(); editor.redo?.(); return; }

  // Delete / Backspace
  if (key === 'delete' || key === 'backspace') {
    e.preventDefault();
    if (activeObj) { canvas.remove(activeObj); canvas.discardActiveObject(); canvas.requestRenderAll(); }
    return;
  }

  // Arrow keys
  if (activeObj) {
    e.preventDefault();
    switch(key) {
      case 'arrowup': activeObj.top -= moveStep; break;
      case 'arrowdown': activeObj.top += moveStep; break;
      case 'arrowleft': activeObj.left -= moveStep; break;
      case 'arrowright': activeObj.left += moveStep; break;
    }
    activeObj.setCoords();
    canvas.requestRenderAll();
  }
});

// --- Resize canvas ---
window.addEventListener('resize', () => {
  editor.resize(window.innerWidth, window.innerHeight);
  canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
  canvas.requestRenderAll();
});
</script>
</body>
</html>
