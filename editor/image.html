<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Image Editor – TOAST UI Example</title>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/tui-image-editor/3.15.3/tui-image-editor.min.css"
  />
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden;
      font-family: Verdana, sans-serif;
      background: #222; color: #fff;
    }
    #editorContainer {
      width: 100%; height: 100%;
    }
    /* Crosshair cursor inside editor area */
    #editorContainer, #editorContainer .tui-image-editor-canvas-container {
      cursor: crosshair;
    }
  </style>
</head>
<body>

<div id="editorContainer"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.6.0/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tui-image-editor/3.15.3/tui-image-editor.min.js"></script>
<script>
  const container = document.getElementById('editorContainer');
  const editor = new tui.ImageEditor(container, {
    includeUI: {
      loadImage: {
        path: '',
        name: 'Untitled'
      },
      menu: ['crop', 'flip', 'rotate', 'draw', 'shape', 'text', 'filter', 'icon'],
      initMenu: 'draw',
      menuBarPosition: 'top'
    },
    cssMaxWidth: window.innerWidth,
    cssMaxHeight: window.innerHeight,
    usageStatistics: false
  });

  // Tune zoom/pan speed (example: slower zoom)
  const zoomStep = 0.9;  // adjust: <1 = slower zoom
  // Here we modify wheel zoom behaviour on the underlying fabric canvas
  const canvas = editor.getCanvas();
  canvas.on('mouse:wheel', function(opt) {
    opt.e.preventDefault();
    const delta = opt.e.deltaY;
    let zoom = canvas.getZoom();
    zoom = zoom * (delta < 0 ? (1 / zoomStep) : zoomStep);
    zoom = Math.max(0.1, Math.min(zoom, 20));
    canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
    opt.e.stopPropagation();
  });

  // Make Ctrl+Drag / Cmd+Drag pan
  canvas.on('mouse:down', function(opt) {
    const evt = opt.e;
    if ((evt.ctrlKey || evt.metaKey) && !opt.target) {
      this.isDragging = true;
      this.lastPosX = evt.clientX;
      this.lastPosY = evt.clientY;
      this.selection = false;
    }
  });
  canvas.on('mouse:move', function(opt) {
    if (this.isDragging) {
      const e = opt.e;
      const vpt = canvas.viewportTransform;
      vpt[4] += e.clientX - this.lastPosX;
      vpt[5] += e.clientY - this.lastPosY;
      canvas.requestRenderAll();
      this.lastPosX = e.clientX;
      this.lastPosY = e.clientY;
    }
  });
  canvas.on('mouse:up', function(opt) {
    this.isDragging = false;
    this.selection = true;
  });

  // Resize editor on window resize
  window.addEventListener('resize', () => {
    editor.ui.resizeEditor({ cssMaxWidth: window.innerWidth, cssMaxHeight: window.innerHeight });
  });

</script>

</body>
</html>
