<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Art Editor with Transparency</title>
<style>
  html, body { margin:0; padding:0; height:100%; font-family:Verdana,sans-serif; background:#222; color:#fff; }
  #toolbar { display:flex; gap:4px; padding:4px; background:#333; align-items:center; flex-wrap:wrap; }
  #toolbar button { padding:4px 8px; background:#444; color:#fff; border:none; cursor:pointer; }
  #toolbar button.active { background:#666; }
  #toolbar input[type=color], #toolbar input[type=range] { margin-left:4px; }
  #canvasContainer { flex:1; position:relative; overflow:auto; background:#111; cursor:crosshair; }
  canvas { display:block; background:transparent; image-rendering:pixelated; }
</style>
</head>
<body>
<div id="toolbar">
  <button id="toolPencil" class="active">Pencil</button>
  <button id="toolRect">Rectangle</button>
  <button id="toolFill">Fill</button>
  <button id="toolEraser">Eraser</button>
  <label>Color: <input type="color" id="colorPicker" value="#ff0000"></label>
  <label>Pixel Size: <input type="range" id="pixelSize" min="4" max="32" value="16"></label>
  <button id="undoBtn">Undo</button>
  <button id="redoBtn">Redo</button>
</div>
<div id="canvasContainer" style="flex:1; display:flex;">
  <canvas id="pixelCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');

let gridWidth = 16;
let gridHeight = 16;
let pixelSize = 16;
let currentTool = 'pencil';
let currentColor = '#ff0000';
let isDrawing = false;
let startX = 0, startY = 0;

// Undo/Redo stack
let undoStack = [], redoStack = [];
function saveState() {
  redoStack = [];
  undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height));
  if(undoStack.length > 50) undoStack.shift();
}
function undo() { if(undoStack.length){ redoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height)); ctx.putImageData(undoStack.pop(),0,0); }}
function redo() { if(redoStack.length){ undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height)); ctx.putImageData(redoStack.pop(),0,0); }}

// Initialize canvas
function resizeCanvas() {
  canvas.width = gridWidth * pixelSize;
  canvas.height = gridHeight * pixelSize;
  drawGrid();
}
function drawGrid() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = '#333';
  for(let x=0;x<=gridWidth;x++){
    ctx.beginPath(); ctx.moveTo(x*pixelSize,0); ctx.lineTo(x*pixelSize,canvas.height); ctx.stroke();
  }
  for(let y=0;y<=gridHeight;y++){
    ctx.beginPath(); ctx.moveTo(0,y*pixelSize); ctx.lineTo(canvas.width,y*pixelSize); ctx.stroke();
  }
}

// Tools
function getMousePos(e){
  const rect = canvas.getBoundingClientRect();
  return {
    x: Math.floor((e.clientX - rect.left)/pixelSize),
    y: Math.floor((e.clientY - rect.top)/pixelSize)
  };
}
function drawPixel(x,y,color){
  ctx.fillStyle = color;
  ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
}

// Flood fill
function floodFillPixelArt(x, y, color) {
  const grid = [];
  for (let gx = 0; gx < gridWidth; gx++) {
    grid[gx] = [];
    for (let gy = 0; gy < gridHeight; gy++) {
      const px = gx * pixelSize;
      const py = gy * pixelSize;
      const data = ctx.getImageData(px, py, 1, 1).data;
      grid[gx][gy] = `rgba(${data[0]},${data[1]},${data[2]},${data[3]/255})`;
    }
  }

  const targetColor = grid[x][y];
  if(targetColor === color) return;

  const stack = [[x, y]];
  while (stack.length) {
    const [cx, cy] = stack.pop();
    if(cx<0||cy<0||cx>=gridWidth||cy>=gridHeight) continue;
    if(grid[cx][cy] !== targetColor) continue;
    grid[cx][cy] = color;
    drawPixel(cx, cy, color);
    stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
  }
}

// Rectangle drawing
function drawRect(x1,y1,x2,y2,color){
  const xmin = Math.min(x1,x2), xmax=Math.max(x1,x2);
  const ymin = Math.min(y1,y2), ymax=Math.max(y1,y2);
  for(let x=xmin;x<=xmax;x++) for(let y=ymin;y<=ymax;y++) drawPixel(x,y,color);
}

// Mouse events
canvas.addEventListener('mousedown', e => {
  const pos = getMousePos(e);
  startX = pos.x; startY = pos.y;
  isDrawing = true;
  saveState();
  if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor);
  if(currentTool==='eraser') drawPixel(pos.x,pos.y,'rgba(0,0,0,0)');
  if(currentTool==='fill') floodFillPixelArt(pos.x,pos.y,currentColor);
});
canvas.addEventListener('mousemove', e => {
  if(!isDrawing) return;
  const pos = getMousePos(e);
  if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor);
  if(currentTool==='eraser') drawPixel(pos.x,pos.y,'rgba(0,0,0,0)');
});
canvas.addEventListener('mouseup', e => {
  if(currentTool==='rect') {
    const pos = getMousePos(e);
    drawRect(startX,startY,pos.x,pos.y,currentColor);
  }
  isDrawing = false;
});

// Toolbar buttons
const toolButtons = {
  pencil: document.getElementById('toolPencil'),
  rect: document.getElementById('toolRect'),
  fill: document.getElementById('toolFill'),
  eraser: document.getElementById('toolEraser'),
};
function selectTool(toolName) {
  currentTool = toolName;
  Object.keys(toolButtons).forEach(t=>{
    toolButtons[t].classList.toggle('active', t === toolName);
  });
}
toolButtons.pencil.onclick = ()=>selectTool('pencil');
toolButtons.rect.onclick = ()=>selectTool('rect');
toolButtons.fill.onclick = ()=>selectTool('fill');
toolButtons.eraser.onclick = ()=>selectTool('eraser');

document.getElementById('colorPicker').onchange = e=>currentColor=e.target.value;
document.getElementById('pixelSize').oninput = e=>{ pixelSize=parseInt(e.target.value); resizeCanvas(); drawGrid(); };
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// Save/load 16x16
const exportWidth = 16;
const exportHeight = 16;

function saveProject() {
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = exportWidth;
  exportCanvas.height = exportHeight;
  const exportCtx = exportCanvas.getContext('2d');
  exportCtx.clearRect(0,0,exportWidth,exportHeight);

  for(let y=0;y<exportHeight;y++){
    for(let x=0;x<exportWidth;x++){
      const sx = x * pixelSize;
      const sy = y * pixelSize;
      const data = ctx.getImageData(sx,sy,1,1).data;
      exportCtx.fillStyle = `rgba(${data[0]},${data[1]},${data[2]},${data[3]/255})`;
      exportCtx.fillRect(x,y,1,1);
    }
  }
  return exportCanvas.toDataURL('image/png');
}

function loadProject(base64) {
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img,0,0,img.width,img.height,0,0,gridWidth*pixelSize,gridHeight*pixelSize);
    drawGrid();
  };
  img.src = base64;
}

// Initialize
resizeCanvas();
drawGrid();

</script>
</body>
</html>
